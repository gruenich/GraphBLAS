FUTURE plans for GraphBLAS:

    JIT package: don't just check 1st line of GraphBLAS.h when deciding to
        unpack the src in user cache folder. Use a crc test.

    cumulative sum (or other monoid)

    Raye: link-time optimization with binary for operators, for Julia

    pack/unpack COO

    kernel fusion

    CUDA kernels
        CUDA: finding src
        CUDA: kernel source location, and name

    distributed framework

    fine-grain parallelism for dot-product based mxm, mxv, vxm,
        then add GxB_vxvt (outer product) and GxB_vtxv (inner product)
        (or call them GxB_outerProduct and GxB_innerProduct?)

    aggregators

    GrB_extract with GrB_Vectors instead of (GrB_Index *) arrays for I and J

    iso: set a flag with GrB_get/set to disable iso.  useful if the matrix is
    about to become non-iso anyway. Pagerank does:

        r = teleport (becomes iso)
        r += A*x     (becomes non-iso)

    apply: C = f(A), A dense, no mask or accum, C already dense: do in place

    JIT: allow a flag to be set in a type or operator to selectively control
        the JIT

    JIT: requires GxB_BinaryOp_new to give the string that defines the op.
    Allow use of
        GrB_BinaryOp_new (...)
        GrB_set (op, GxB_DEFN, "string")
    also for all ops

    monoids with terminal conditions (as a function), not just a terminal
        value

    candidates for kernel fusion:
        * triangle counting: mxm then reduce to scalar
        * lcc: mxm then reduce to vector
        * FusedMM: see https://arxiv.org/pdf/2011.06391.pdf

    more:
        * consider algorithms where fusion can occur
        * performance monitor, or revised burble, to detect generic cases
        * check if vectorization of GrB_mxm is effective when using clang
        * see how HNSW vector search could be implemented in GraphBLAS

integer sizes:
        use 32-bit or 64-bit integers in A->i, A->h, and A->p.
        >>> requires generic pack/unpack method for O(1) move constructors.
        could use new build methods (int32 indices), or GrB_Vectors for I and J.
        does not require new extracTuples method (simply typecast the copy).
        could use new GrB_*import/export methods, with int32 indices, or just
            typecast on copy.

All JIT kernels can be specialized to the int types of its matrices.
FactoryKernels and generic kernels cannot; they would need to use the above
macros.  Or, current single-integer codes with no specializations would use:

    if (all matrices are 32 bit)
        use all 32 bit Ai and Ah for all matrices
    else if all 64
        use all 64 bit Ai and Ah for all matrices
    else
        use generic macros as above

The code inside each of the 3 cases above would be templatized methods.

